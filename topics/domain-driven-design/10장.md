## 10장 유연한 설계

### 258p
복잡하게 동작하는 소프트웨어에 좋은 설계가 결여돼 있다면 요소들을 리팩터링하거나 결합하기가 어려워진다.
개발자들이 소프트웨어의 처리 방식에 내포된 모든 의미를 확신하지 못하면 곧바로 중복이 나타나기 시작한다.
설계 요소가 모놀리식(monolithic)으로 구성돼 있을 경우 중복을 할수 밖에 없기 때문에 각 부분을 재결합하기가 불가능해진다.

...

개발이 진행될수록 현재의 레거시 코드로 인한 중압감에 시달리지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업할 수 있는 설계가 필요하다. 바로 유연한 설계(supple design)가 그것이다.


### 261p 의도를 드러내는 인터페이스
클라이언트 개발자가 객체를 효과적으로 사용하는 데 알아야 할 정보를 인터페이스로부터 얻지 못한다면 세부적인 측면을 이해하고자 객체 내부를 깊이 파고들 수밖에 없다. 클라이언트 코드를 읽게 될 다른 개발자들도 같은 일을 해야 하는 수고를 감내해야 한다. 그러면 캡슐화로부터 얻을 수 있는 대부분의 가치를 잃어버리고 만다.

...

개발자가 컴포넌트를 사용하기 위해 컴포넌트의 구현 세부사항을 고려해야 한다면 캡슐화의 가치는 사라진다. 원래의 개발자가 아닌 다른 개발자가 구현 내용을 토대로 객체나 연산의 목적을 추측해야 한다면 새로운 개발자는 우연에 맡긴 채 연산이나 클래스의 목적을 짐작할 가능성이 있다. 추측한 바가 원래의 취지에 어긋난다면 당장은 코드가 정상적으로 동작했다고 하더라도 설계의 개념적 기반은 무너지고 두 개발자는 서로 의도가 어긋난 상태로 일하게 된다.



### 262p
수행 방법에 관해서는 언급하지 말고 결과와 목적만을 표현하도록 클래스와 연산의 이름을 부여하라.

### 266 - 267p
연산은 크게 명령(command)와 질의(query)라는 두 가지 범주로 나눌 수 있다.
질의는 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산을 의미한다.
명령은 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산을 의미한다.
부수효과를 일으키지 않으면서 결과를 반환하는 연산을 함수(function)라고 한다.
상태 변경을 수반하는 로직과 계산이 혼합된 연산은 리팩터링을 거쳐 두 개의 연산으로 분리해야 한다.
