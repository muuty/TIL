
#### 6p
설계란 무엇인가? 아키텍처는? 둘 사이에는 어떤 차이가 있는가? (...) 첫째로 주장하고 싶은 바는 둘 사이에는 차이가 없다는 점이다.

#### 7p
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 필요한 인력을 최소화하는 데 있다.


#### 38p
좋은 아키텍처를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는 데서 출발한다.


#### 51p
소프트웨어 아키텍트 관점에서 정답은 명황하가. OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.


### SOLID 원칙의 목적 62p
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.


### SRP 원칙
SRP의 최종 버전은 아래와 같다.
'하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.'

### OCP 원칙
소프트웨어 객체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의졵성 계층구조가 만들어지도록 해야 한다.

### 리스코프 치환법칙
S타입의 객체 o1 각각에 해당하는 T1 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.

### 인터페이스 분리 원칙
오퍼레이션을 인터페이스 단위로 분리하여서, 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.

### 의존성 역전 원칙
'유연성이 극대화된 시스템'이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
- 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라,
- 변동성이 큰 구체 클래스로부터 파생하지 말라.
- 구체 함수를 오버라이드 하지 말라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.